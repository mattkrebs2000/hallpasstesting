{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { InterruptionModeAndroid, InterruptionModeIOS } from \"./Audio.types\";\nimport ExponentAV from \"./ExponentAV\";\nexport * from \"./Audio/Recording\";\nexport * from \"./Audio/Sound\";\nexport { setIsEnabledAsync } from \"./Audio/AudioAvailability\";\nexport { PitchCorrectionQuality } from \"./AV\";\nvar _populateMissingKeys = function _populateMissingKeys(userAudioMode, defaultAudioMode) {\n  for (var key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n  return userAudioMode;\n};\nvar defaultMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: InterruptionModeIOS.MixWithOthers,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: false\n};\nvar currentAudioMode = null;\nfunction getCurrentAudioMode() {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n  return currentAudioMode;\n}\nexport function setAudioModeAsync(_x) {\n  return _setAudioModeAsync.apply(this, arguments);\n}\nfunction _setAudioModeAsync() {\n  _setAudioModeAsync = _asyncToGenerator(function* (partialMode) {\n    var mode = _populateMissingKeys(partialMode, getCurrentAudioMode());\n    if (!InterruptionModeIOS[mode.interruptionModeIOS]) {\n      throw new Error(\"\\\"interruptionModeIOS\\\" was set to an invalid value.\");\n    }\n    if (!InterruptionModeAndroid[mode.interruptionModeAndroid]) {\n      throw new Error(\"\\\"interruptionModeAndroid\\\" was set to an invalid value.\");\n    }\n    if (typeof mode.allowsRecordingIOS !== 'boolean' || typeof mode.playsInSilentModeIOS !== 'boolean' || typeof mode.staysActiveInBackground !== 'boolean' || typeof mode.shouldDuckAndroid !== 'boolean' || typeof mode.playThroughEarpieceAndroid !== 'boolean') {\n      throw new Error('\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.');\n    }\n    currentAudioMode = mode;\n    return yield ExponentAV.setAudioMode(mode);\n  });\n  return _setAudioModeAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/Audio.ts"],"names":[],"mappings":";AAAA,SAAoB,uBAAuB,EAAE,mBAAmB;AAChE,OAAO,UAAU;AAEjB;AACA;AACA,SAAS,iBAAiB;AAC1B,SAAS,sBAAsB;AAE/B,IAAM,oBAAoB,GAAG,SAAvB,oBAAoB,CACxB,aAAiC,EACjC,gBAA2B,EACd;EACb,KAAK,IAAM,GAAG,IAAI,gBAAgB,EAAE;IAClC,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;MACtC,aAAa,CAAC,GAAG,CAAC,GAAG,gBAAgB,CAAC,GAAG,CAAC;IAC3C;EACF;EACD,OAAO,aAA0B;AACnC,CAAC;AAED,IAAM,WAAW,GAAc;EAC7B,kBAAkB,EAAE,KAAK;EACzB,mBAAmB,EAAE,mBAAmB,CAAC,aAAa;EACtD,oBAAoB,EAAE,KAAK;EAC3B,uBAAuB,EAAE,KAAK;EAC9B,uBAAuB,EAAE,uBAAuB,CAAC,UAAU;EAC3D,iBAAiB,EAAE,IAAI;EACvB,0BAA0B,EAAE;CAC7B;AAED,IAAI,gBAAgB,GAAqB,IAAI;AAE7C,SAAS,mBAAmB,GAAA;EAC1B,IAAI,CAAC,gBAAgB,EAAE;IACrB,OAAO,WAAW;EACnB;EACD,OAAO,gBAAgB;AACzB;AAOA,gBAAsB,iBAAiB;EAAA;AAAA;AAsBtC;EAAA,uCAtBM,WAAiC,WAA+B,EAAA;IACrE,IAAM,IAAI,GAAG,oBAAoB,CAAC,WAAW,EAAE,mBAAmB,EAAE,CAAC;IAErE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE;MAClD,MAAM,IAAI,KAAK,wDAAsD;IACtE;IACD,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,uBAAuB,CAAC,EAAE;MAC1D,MAAM,IAAI,KAAK,4DAA0D;IAC1E;IACD,IACE,OAAO,IAAI,CAAC,kBAAkB,KAAK,SAAS,IAC5C,OAAO,IAAI,CAAC,oBAAoB,KAAK,SAAS,IAC9C,OAAO,IAAI,CAAC,uBAAuB,KAAK,SAAS,IACjD,OAAO,IAAI,CAAC,iBAAiB,KAAK,SAAS,IAC3C,OAAO,IAAI,CAAC,0BAA0B,KAAK,SAAS,EACpD;MACA,MAAM,IAAI,KAAK,CACb,iJAAiJ,CAClJ;IACF;IACD,gBAAgB,GAAG,IAAI;IACvB,aAAa,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC;EAC5C,CAAC;EAAA;AAAA","sourcesContent":["import { AudioMode, InterruptionModeAndroid, InterruptionModeIOS } from './Audio.types';\nimport ExponentAV from './ExponentAV';\n\nexport * from './Audio/Recording';\nexport * from './Audio/Sound';\nexport { setIsEnabledAsync } from './Audio/AudioAvailability';\nexport { PitchCorrectionQuality } from './AV';\n\nconst _populateMissingKeys = (\n  userAudioMode: Partial<AudioMode>,\n  defaultAudioMode: AudioMode\n): AudioMode => {\n  for (const key in defaultAudioMode) {\n    if (!userAudioMode.hasOwnProperty(key)) {\n      userAudioMode[key] = defaultAudioMode[key];\n    }\n  }\n  return userAudioMode as AudioMode;\n};\n\nconst defaultMode: AudioMode = {\n  allowsRecordingIOS: false,\n  interruptionModeIOS: InterruptionModeIOS.MixWithOthers,\n  playsInSilentModeIOS: false,\n  staysActiveInBackground: false,\n  interruptionModeAndroid: InterruptionModeAndroid.DuckOthers,\n  shouldDuckAndroid: true,\n  playThroughEarpieceAndroid: false,\n};\n\nlet currentAudioMode: AudioMode | null = null;\n\nfunction getCurrentAudioMode(): AudioMode {\n  if (!currentAudioMode) {\n    return defaultMode;\n  }\n  return currentAudioMode;\n}\n\n/**\n * We provide this API to customize the audio experience on iOS and Android.\n * @param partialMode\n * @return A `Promise` that will reject if the audio mode could not be enabled for the device.\n */\nexport async function setAudioModeAsync(partialMode: Partial<AudioMode>): Promise<void> {\n  const mode = _populateMissingKeys(partialMode, getCurrentAudioMode());\n\n  if (!InterruptionModeIOS[mode.interruptionModeIOS]) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (!InterruptionModeAndroid[mode.interruptionModeAndroid]) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.staysActiveInBackground !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean' ||\n    typeof mode.playThroughEarpieceAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  currentAudioMode = mode;\n  return await ExponentAV.setAudioMode(mode);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}